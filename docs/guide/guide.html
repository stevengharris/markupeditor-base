<h1>Developer's Guide</h1>

<h2>Concepts</h2>

<p>The MarkupEditor in its “base” form is a what-you-see-is-what-you-get (<em>WYSIWYG</em>) editor meant to be embedded in an application of some kind. It comes with a configurable and extensible toolbar that provides UI access to its underlying editing functionality. The document you edit with the MarkupEditor is standard HTML with a limited set of supported tags. The document is styled using CSS, which you can override and supplement. As you edit the HTML document, the editor lets you know when changes occur, so you can take action based on your specific application context.</p>

<p>The <em>application environment</em> you’re building-for needs to support a web view, so you can load the MarkupEditor script and use the CSS styling that comes with it. We’re using the nebulous term “application environment” in this document, because that could be <em>Node.js</em> or <em>Electron</em> or <em>MacOS AppKit</em> or <em>iOS SwiftUI</em> or… the list goes on. The language you’re writing your application in could be JavaScript or any other language, as long as the application environment supports a web view and the mechanics of communicating to/from the web view and the MarkupEditor within it.</p>

<h3>Goals and Non-Goals</h3>

<p>A key goal of the MarkupEditor is that application developers be able to embed WYSIWYG editing functionality in any environment. They should be able to customize the editor’s appearance and behavior without having to fork the <a href="https://github.com/stevengharris/markupeditor-base">code</a>, or even having to learn much beyond how to get and set the HTML being edited. The MarkupEditor’s scope resembles and is by-design limited to Markdown’s scope. It doesn’t provide any direct support for fonts and styles, positioning text on a page, and other elaborate formatting. Like Markdown, it only supports the limited set of features you need to organize what you’re writing to get your points across effectively. It does not support import/export from/to Markdown or any other document formats. Since a MarkupEditor document consists of standard “clean” HTML without embedded styles or classes, there is an entire world of tools you can use to parse a MarkupEditor document, save it, search it, and export it. If you do transform the MarkupEditor’s clean HTML to some other form, like Markdown, just be aware that what you see in the MarkupEditor may not be what your end-users get.</p>

<h2>Essentials</h2>

<p>Let’s take a look at what is required for WYSIWYG editing directly in your web browser or using Node.js. These “essentials” are common to other environments that the MarkupEditor can be used in.</p>

<h3>Using the MarkupEditor in a Browser</h3>

<p>By our nebulous definition, a web browser provides an application environment. Here’s an <a href="https://stevengharris.github.io/markupeditor-base/helloworld/index.html"><code>index.html</code></a> you can load in your browser to display an editable version of “Hello, world!”:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;Hello MarkupEditor&lt;/title&gt;
        &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
        &lt;link href="../styles/markupeditor.css" rel="stylesheet"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="editor"&gt;&lt;/div&gt;
        &lt;script src="../src/markupeditor.umd.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            new MU.MarkupEditor(document.querySelector('#editor'), {html: '&lt;h1&gt;Hello, world!&lt;/h1&gt;'})
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The essentials involve:</p>

<ol>
    <li>
        <p>Linking to the MarkupEditor style sheets that are gathered together in <code>markupeditor.css</code>.</p>
    </li>
    <li>
        <p>Creating an empty <code>editor</code> div to edit in.</p>
    </li>
    <li>
        <p>Loading the MarkupEditor script <code>markupeditor.umd.js</code> which exposes its public API in a global, <code>MU</code>.</p>
    </li>
    <li>
        <p>Creating an instance of the MarkupEditor in the editor element, and in this case providing its initial HTML.</p>
    </li>
</ol>

<p>These essentials are common whenever you use the MarkupEditor, but the details will vary.</p>

<p><img src="c4f425be-396a-40b0-a219-4e599b921872.png" width="432" height="237"></p>

<p>Above, you see the result in the Vivaldi browser. Note the default toolbar shows up without any work on your part. The MarkupEditor lets you edit the document, but there is a very security-limited set of things you can do from a browser. While the browser is pretty much the simplest possible environment to use the MarkupEditor in, it also provides access to an array of development tools for debugging.</p>

<blockquote>
    <p><strong>Note</strong>: If you encounter a MarkupEditor bug, providing a test or usage flow that reproduces the bug in a browser will ensure it can be debugged with no setup barriers, increasing the likelihood of it being worked on.</p>
</blockquote>

<h3>Using the MarkupEditor in Node.js</h3>

<p>When you use the MarkupEditor in Node.js, you get access to the file system, among other things. In concrete terms, this means you can fetch file contents without the requirement that the access be gated by a trusted user action, as is required in the browser. The MarkupEditor lets you identify a <code>filename</code> containing the HTML contents it will show. Here’s how the contents of <code>guide.html</code> (which you’re reading now) are loaded into the MarkupEditor:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;docs/demo/demo.html&lt;/title&gt;
    &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="styles/markupeditor.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="editor"&gt;&lt;/div&gt;
    &lt;script src="dist/markupeditor.umd.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      new MU.MarkupEditor(document.querySelector('#editor'), {filename: "docs/guide/guide.html", base: "docs/guide/"})
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Note that if you saved the HTML shown above as a file and attempted to load it in your browser, say by double-clicking on the file, it would fail with <code>Failed to load docs/guide/guide.html</code>. You would see the toolbar show up, but the browser fails when fetching <code>guide.html</code>. You can, however, do it with Node.js! Here is a script, <code>guide.js</code>, that can be executed using <code>node guide.js</code>:</p>

<pre><code>const express = require('express');

const app = express();

// Allow the relative references for css and scripts to work
app.use(express.static(`${__dirname}`, { index: false }))

// For parsing application/json
app.use(express.json())

// Load when loading http://localhost:${port}
app.get('/', (req, res) =&gt; {
  res.send(
    `
      &lt;!DOCTYPE html&gt;
      &lt;html lang="en"&gt;
        &lt;head&gt;
          &lt;title&gt;docs/demo/demo.html&lt;/title&gt;
          &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
          &lt;link href="styles/markupeditor.css" rel="stylesheet"&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="editor"&gt;&lt;/div&gt;
          &lt;script src="dist/markupeditor.umd.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            new MU.MarkupEditor(document.querySelector('#editor'), {filename: "docs/guide/guide.html", base: "docs/guide/"})
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    `
  )
});

app.listen('3000', () =&gt; {
  console.log(`Server listening at http://localhost:3000`);
});</code></pre>

<p>Here we use <a href="https://expressjs.com">Express</a> to respond with the HTML we showed earlier when you open your browser on <code>http://localhost:3000</code>. Note that <code>base</code> is passed as part of the MarkupEditor configuration. Under the covers, this ends up adding an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/base">HTML base element</a> to the document, so that the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/img"><code>img src</code></a> attribute and other references in the document are specified relative to the HTML document being edited.</p>

<p>There is a more robust version of this script - <a href="https://github.com/stevengharris/markupeditor-base">markupeditor.js</a> in the markupeditor-base project - that you can execute from anywhere, identifying the HTML file to open (or none if you just want an empty document) and the port to listen on. For example:</p>

<pre><code>$ node markupeditor.js docs/demo/demo.html --port 8000
Server listening at http://localhost:8000</code></pre>

<p>The MarkupEditor documentation, including this Developer Guide, is hosted using GitHub Pages. You can use npm/node to view the docs locally using:</p>

<pre><code>$ npm run docs

&gt; markupeditor-base@0.8.0 predocs
&gt; sh predocs.sh

Updating ./docs dependencies...
cp -f ./dist/markupeditor.umd.js ./docs/src/markupeditor.umd.js
cp -f ./styles/markupeditor.css ./docs/styles/markupeditor.css
cp -f ./styles/markup.css ./docs/styles/markup.css
cp -f ./styles/mirror.css ./docs/styles/mirror.css
cp -f ./styles/toolbar.css ./docs/styles/toolbar.css

&gt; markupeditor-base@0.8.0 docs
&gt; node ./docs/index.js

Server listening at http://localhost:3000</code></pre>

<p>Besides invoking node on the <code>index.js</code> in the docs directory, the script runs a “predocs” step that copies the required MarkupEditor files into locations in the docs directory. When the changes are pushed to GitHub, it kicks off a refresh of the <a href="https://stevengharris.github.io/markupeditor-base/">project web site</a>. This process makes for a nice closed loop - edit the project web site contents locally using the MarkupEditor, and then update the site when the changes are pushed to GitHub.</p>

<p>This is the extent of “application environments” that are supported out-of-the-box when you install the MarkupEditor base project. It’s the minimum needed to develop and debug the MarkupEditor in its base form. The MarkupEditor can, however, be embedded in other environments. Before we cover that, let’s cover configuration, how you use the MarkupEditor API, and how to hook into the notifications it provides as you edit a document.</p>

<h2>Configuration</h2>

<p>So far, we have seen how to pass some initial HTML to the MarkupEditor, and how to identify a <code>filename</code> to open using Node.js. When you want to call into the MarkupEditor, you do that by invoking the public API exposed via the <code>MU</code> object. We saw <code>MU</code> used earlier when we created an instance of MarkupEditor using <code>new MU.MarkupEditor(&lt;target div&gt;, &lt;config&gt;)</code>. Let’s examine the configuration passed when the MarkupEditor instance is created.</p>

<h3>Configuration Classes</h3>

<p>There are three configuration classes:</p>

<ul>
    <li>
        <p><code>ToolbarConfig</code> specifies whether the toolbar itself is visible, which sub-toolbars/dropdowns are visible, and which items are included in each.</p>
    </li>
    <li>
        <p><code>KeymapConfig</code> specifies how editing actions map to key combos (aka hotkeys).</p>
    </li>
    <li>
        <p><code>BehaviorConfig</code> specifies various ways the MarkupEditor behaves that are not specific to the menu/toolbar or keymap configurations.</p>
    </li>
</ul>

<p>You can view the full set of options in each configuration class in the <a href="https://stevengharris.github.io/markupeditor-base/api/index.html">MarkupEditor API</a>. Each config provides a <code>standard()</code> static function that returns the default configuration used by the MarkupEditor when you don’t specify a configuration. Note that <code>ToolbarConfig</code> is independent of <code>KeymapConfig</code> because, for example, while you may <em>not</em> want to display undo and redo buttons in the toolbar, you <em>will</em> want to map them to hotkeys like <code>Cmd+S</code> and <code>Shift+Cmd+S</code> (the default in both cases).</p>

<p>A simple way to customize configuration is to use one of the pre-defined static methods to get a config object back. You can then modify that config object as needed. Going all the way back to our “Hello, world!” example, we could add the undo/redo buttons in by making the correction sub-toolbar visible, turn off the ability for users to insert tables, and we could change the hotkey used for adding a link:</p>

<pre><code>&lt;script&gt;
    let toolbarConfig = MU.ToolbarConfig.standard(true)   // The standard toolbar but with undo/redo showing
    toolbarConfig.insertBar.table = false;                // Turn off table insert
    let keymapConfig = MU.KeymapConfig.standard();        // Grab the standard keymap config as a baseline
    keymapConfig.link = ["Ctrl-L", "Ctrl-l"];             // Use Control+L instead of Command+k
    new MU.MarkupEditor(
        document.querySelector('#editor'), {
            html: '&lt;h1&gt;Hello, world!&lt;/h1&gt;',
            toolbar: toolbarConfig,
            keymap: keymapConfig
        }
    )
&lt;/script&gt;</code></pre>

<p>Besides the <code>html</code>, <code>filename</code>, <code>toolbar</code>, <code>keymap</code>, and <code>behavior</code> properties, you can also pass <code>placeholder</code> html to show when the document is empty. Let’s take a closer look at each of the configuration classes.</p>

<h3>ToolbarConfig</h3>

<p>The ToolbarConfig is easier to explain with a picture, because it refers to various pieces of the toolbar by name, and the names make more sense when you can see the toolbar. Here is the full toolbar in all its glory. This toolbar was obtained by defining <code>toolbarConfig = MU.ToolbarConfig.full(true)</code> and then passing <code>toolbar: toolbarConfig</code> in the MarkupEditor configuration. (The <code>true</code> argument specifies that undo/redo should be visible in the <code>full</code> toolbar.) Note that the <code>ToolbarConfig.standard()</code> does not display undo/redo, underline, and subscript/superscript.</p>

<p><img src="69ac24ab-f2b9-4e61-b9fa-a2320719475f.png" width="825" height="148"></p>

<h4>Visibility</h4>

<p>You can control the visibility of each of the individual bars and menus by name; for example, <code>toolbarConfig.visibility.correctionBar = false</code> or <code>toolbarConfig.visibility.search = false.</code> Within the bars and menus, you can also control what is visible. For example, <code>toolbarConfig.insertBar.table = false</code> will remove the <em>tableMenu</em>. Within the <em>tableMenu</em>, you can control whether it includes a <em>Header</em> or <em>Border</em> item. The individual controls are itemized with comments in <code>src/setup/toolbarconfig.js</code>. It’s also possible to turn off the overall toolbar using <code>toolbarConfig.visibility.toolbar = false</code>. This is useful when you define your own toolbar, something that is done in the Swift MarkupEditor.</p>

<h4>Style Visibility and Names</h4>

<p>The names in the <em>styleMenu</em> can be set as part of the ToolbarConfig. For example, to use “Normal” for the &lt;P&gt; element rather than “Body”, you would specify <code>toolbarConfig.styleMenu.p = “Normal”</code>. If you want to remove an item, set its value to <code>null</code>. For example, <code>toolbarConfig.style.pre = null</code> will remove the <em>Code</em> item from the <em>styleMenu</em> (because code blocks are <code>&lt;pre&gt;&lt;code&gt;</code> in the HTML).</p>

<h4>Ordering</h4>

<p>TBD.</p>

<h4>Icons</h4>

<p>TBD.</p>

<h3>KeymapConfig</h3>

<p>TBD.</p>

<h3>BehaviorConfig</h3>

<p>TBD.</p>

<h2>Communicating with the MarkupEditor</h2>

<p>It’s important to recognize <em>where</em> your code is executing when using the MarkupEditor. In the configuration example, we are executing a script that is running inside of the web view itself. The global <code>MU</code> was created when you loaded <code>markupeditor.umd.js</code> earlier, so it’s available for you to reference directly in any script you load <em>after</em> <code>markupeditor.umd.js</code>. When you are executing in the application environment process you used to create and hold the web view, like Node.js or an iOS app, you will have to access <code>MU</code> with a call to something like <code>executeJavaScript</code>. We will cover that a little later.</p>

<h3>Getting and Setting MarkupEditor Contents</h3>

<p>We’ve see how to set up the initial HTML when you create a MarkupEditor instance in a web view by passing <code>html</code> or <code>filename</code> as part of its configuration. If your environment provides access to the file system and perhaps platform-native dialogs for selecting a file, you will want to get the MarkupEditor contents to save to the file, or set the MarkupEditor contents from the file contents. To get the MarkupEditor contents:</p>

<pre><code>let contents = MU.getHTML()</code></pre>

<p>and to set the contents to an HTML string called <code>htmlString</code>:</p>

<pre><code>MU.setHTML(htmlString)</code></pre>

<h4>HTML Restrictions</h4>

<p>The MarkupEditor uses the following HTML elements:</p>

<ul>
    <li>
        <p>Paragraph Styles: <code>&lt;H1&gt;</code>, <code>&lt;H2&gt;</code>, <code>&lt;H3&gt;</code>, <code>&lt;H4&gt;</code>, <code>&lt;H5&gt;</code>, <code>&lt;H6&gt;</code>, <code>&lt;P&gt;</code>. <code>&lt;P&gt;</code> is the default style, also referred to as "Body" in various places. The <code>&lt;CODE&gt;</code> element is supported as a paragraph style or an inlined format. When used as a paragraph style, it is output as <code>&lt;PRE&gt;&lt;CODE&gt;</code> to preserve its exact form.</p>
    </li>
    <li>
        <p>Formatting: <code>&lt;STRONG&gt;</code>, <code>&lt;EM&gt;</code>, <code>&lt;U&gt;</code>, <code>&lt;CODE&gt;</code>, <code>&lt;S&gt;</code>, <code>&lt;SUB&gt;</code>, <code>&lt;SUP&gt;</code>.</p>
    </li>
    <li>
        <p>Images: <code>&lt;IMG&gt;</code>.</p>
    </li>
    <li>
        <p>Links: <code>&lt;A&gt;</code>.</p>
    </li>
    <li>
        <p>Lists: <code>&lt;UL&gt;</code>, <code>&lt;OL&gt;</code>, <code>&lt;LI&gt;</code>.</p>
    </li>
    <li>
        <p>Tables: <code>&lt;TABLE&gt;</code>, <code>&lt;TR&gt;</code>, <code>&lt;TH&gt;</code>, <code>&lt;TD&gt;</code>.</p>
    </li>
    <li>
        <p>Indenting: <code>&lt;BLOCKQUOTE&gt;</code>.</p>
    </li>
</ul>

<p>When you use <code>setHTML</code> or paste HTML content into the MarkupEditor, it will ignore any elements that do not correspond to these tags. The MarkupEditor will automatically convert <code>&lt;B&gt;</code> to <code>&lt;STRONG&gt;</code>, <code>&lt;I&gt;</code> to <code>&lt;EM&gt;</code>, and <code>&lt;DEL&gt;</code> to <code>&lt;S&gt;</code>. It will also convert some styling, like <code>font-style=italic</code> to the corresponding HTML element. The end result is that you can’t break the MarkupEditor by pasting or setting arbitrary HTML, but it will ingest only what it can display properly and that you can properly edit.</p>

<p>To learn more about how the MarkupEditor interprets incoming HTML and outputs HTML, look at <code>src/schema/index.js</code> in the <a href="https://github.com/stevengharris/markupeditor-base">project repository</a>, and read about <a href="https://prosemirror.net">ProseMirror</a>, which is doing all the heavy lifting behind the scenes.</p>

<h3>MarkupDelegate</h3>

<p>The MarkupEditor makes callbacks to a delegate, aka the <em>MarkupDelegate</em>, as you edit the document and its state changes. You can view the full of set callbacks in the <a href="https://stevengharris.github.io/markupeditor-base/api/index.html">MarkupEditor API</a>. Let’s take a look at how to set up your MarkupDelegate and make use of the callbacks.</p>

<p>Here’s a simple MarkupDelegate. We can put it in a <code>mydelegate.js</code> file and then load it via a script. Its methods will be called when the MarkupEditor is “ready” and when you type into the document or otherwise make editing changes:</p>

<pre><code>class MarkupDelegate {

    // Do something in your app when all scripts are loaded and it's ready.
    markupReady() {
        // For now, just log...
        console.log('The MarkupEditor is ready')
    }

    // Do something in your app when the document receives input from typing or pasting, etc.
    // For example, you might track changes to enable an auto-save feature.
    markupInput() {
        // For now, just log...
        console.log('The MarkupEditor received input')
    }
}</code></pre>

<p>You can load the script and pass the MarkupDelegate instance to the MarkupEditor. Here is what it would look like to load a <code>demo.html</code> file and pass this delegate instance to the MarkupEditor:</p>

<pre><code>&lt;script src="../src/markupeditor.umd.js"&gt;&lt;/script&gt;
&lt;script src="src/mydelegate.js"&gt;&lt;/script&gt;
&lt;script&gt;
    const markupEditor = new MU.MarkupEditor(
        document.querySelector('#editor'), {
            delegate: new MarkupDelegate(),
            placeholder: 'Edit document...',
            filename: 'demo.html',
        }
    )
&lt;/script&gt;</code></pre>

<p>You can call your MarkupDelegate anything you want. The MarkupEditor will only invoke the callbacks if the delegate exists and the function is defined. For example, if you don’t define <code>markupInput</code>, it just won’t be called.</p>

<p>Again, the code in the MarkupDelegate above will execute in the web view. It has access to all of the MarkupEditor functionality via the <code>MU</code> global. Often, access to <code>MU</code> and its functionality will be all you’ll need. For example, the <a href="https://stevengharris.github.io/markupeditor-base/demo/index.html">MarkupEditor demo</a> uses <code>markupInput</code> to update the view of the “raw HTML” as the user edits the document. You can also use the MarkupDelegate to communicate with your application environment, but the mechanism for doing that will be specific to the application environment.</p>

<h3>Round-Trip from the MarkupEditor</h3>

<p>At this point we have covered:</p>

<ul>
    <li>
        <p>How to set up up a web view containing the MarkupEditor and its associated scripts and styling.</p>
    </li>
    <li>
        <p>How to set up a web view containing the MarkupEditor in a Node.js server using Express.</p>
    </li>
    <li>
        <p>How to pass configuration options to the MarkupEditor.</p>
    </li>
    <li>
        <p>How to use a MarkupDelegate to receive notifications as the state changes in the document you’re editing.</p>
    </li>
    <li>
        <p>How to invoke MarkupEditor functionality from with the web view using the <code>MU</code> global.</p>
    </li>
</ul>

<p>What remains is how to access to your application environment, and then in turn, to invoke MarkupEditor functionality from your application environment. The “how” is specific to your environment. We will use a concrete example of selecting an image from the file system when using the MarkupEditor with Electron. The code will all be Electron-specific, but the concepts will be similar in other environments. Ultimately they all need to deal with <em>interprocess communication</em>.</p>

<h4>Selecting an Image</h4>

<p>If you enable “selectImage” in BehaviorConfig, the MarkupEditor shows a “Select…” button in the dialog for inserting images:</p>

<blockquote>
    <p><img src="d505d8fc-ea35-4736-a022-7f6e6a183f1e.png" width="244" height="112"></p>
</blockquote>

<p>Why even make “selectImage” an option? Because:</p>

<ul>
    <li>
        <p>You need access to the file system, which is dependent on your application environment.</p>
    </li>
    <li>
        <p>The MarkupEditor itself doesn’t know how to do this and has very restricted access to the file system.</p>
    </li>
    <li>
        <p>You may be using the MarkupEditor in an environment where you don’t want to allow image selection but still want to be able to insert images by URL.</p>
    </li>
    <li>
        <p>As an app developer, you take on a lot of issues when you allow local images to be inserted in your document. For example… What do you do with the image once you’ve selected it? Do you set your image <code>src</code> to the file itself, or do you encode the file data and embed it? If you point to the file, then what happens when you move your document around or the image file no longer exists? These are all the kinds of issues that separate a demo from a product!</p>
    </li>
</ul>

<p>When you hit the “Select…” button, the MarkupEditor closes the dialog and invokes <code>markupSelectImage</code> in your MarkupDelegate. Remember, your MarkupDelegate is executing in the web view and still has very restricted access to the file system. In the Electron app, your MarkupDelegate would look like this:</p>

<pre><code>class MarkupDelegate {

    markupSelectImage() {
        // Reference the definition in preload.js
        window.markupAPI.selectImage()
    }
}</code></pre>

<p>The <code>window.markupAPI</code> is defined in an <a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-preload">Electron preload script</a> <code>preload.js</code>:</p>

<pre><code>const { contextBridge, ipcRenderer } = require('electron');

/** Define the markupAPI endpoints exposed via windowEvents in main.js */
contextBridge.exposeInMainWorld('markupAPI', {
    selectImage: () =&gt; { ipcRenderer.send('selectImage') },
});</code></pre>

<p>Meanwhile, in our Electron app’s <code>main.js</code>, when the app is ready, we set the app to respond to this new custom event, <code>selectImage</code>:</p>

<pre><code>ipcMain.on('selectImage', handleSelectImage)</code></pre>

<p>When the event is triggered, it will invoke our <code>handleSelectImage</code>. Finally(!!!) we can use Electron’s <code>showOpenDialog</code> to select the file with a native dialog and insert that image data into the MarkupEditor document:</p>

<pre><code>async function handleSelectImage() {
    const { canceled, filePaths } = await dialog.showOpenDialog({
        properties: ['openFile'],
        filters: [
            { name: 'Image', extensions: ['png', 'jpg', 'jpeg', 'gif'] }
        ]
    });

    if (!canceled) {
        let filePath = filePaths[0]
        fs.readFile(filePath, 'base64', (err, data) =&gt; {
            if (err) {
                console.error('Error reading file:', err);
                return;
            }
            let src = srcFromData(filePath, data)
            if (!src) {
                console.error('Unsupported media type')
                return
            }
            let insertImageCommand = `MU.insertImage("${src}")`
            getWebContents()?.executeJavaScript(insertImageCommand)
                .then(()=&gt;{console.log("Done insertImage")})
                .catch((error) =&gt; {
                    console.error('Error inserting image:', error);
                });
        });
    }
}</code></pre>

<p>We can then pass the data as the image <code>src</code> using <code>MU.insertImage</code>. At this point, though, we are executing in the Electron main process, not in the web view which is part of Electron’s renderer process. We have to invoke <code>MU.insertImage</code> using the Electron WebContents and its <code>executeJavaScript</code> method, passing the command to invoke in the web view along with the <code>src</code> data we got from the selected file. <code>MU.insertImage</code> inserts the image at the selection point and updates the document.</p>

<h4>Other Round-Trip Use Cases</h4>

<p>Two “insert” options in the MarkupEditor toolbar - insert link and image - involve user input of some kind. Each uses a MarkupEditor-supplied dialog with input fields that may or may not be appropriate in your application context. (The table insert operation is done using a drop-down menu, not a dialog.) Each dialog can be replaced with your own code without modifying the MarkupEditor itself. Do this by setting <code>insertLink</code> and/or <code>insertImage</code> to <code>true</code> in BehaviorConfig. If you do this with <code>insertLink</code>, your MarkupDelegate’s <code>markupInsertLink</code> method will be called instead of presenting the default LinkDialog. If you do this with <code>insertImage</code>, your MarkupDelegate’s <code>markupInsertImage</code> method will be called instead of presenting the default ImageDialog. If you are using Electron, you can base your implementation of these methods in your MarkupDelegate on the flow discussed above for <code>markupSelectImage</code>.</p>

<h4>More Electron Resources</h4>

<p>You can find the Electron-specific code discussed here in the source of the <a href="https://github.com/stevengharris/markupeditor-desktop">MarkupEditor Desktop app</a>. It supports local images and saves their contents to file at “save time” alongside the document being edited. The desktop app was used to edit this entire Developer’s Guide.</p>

<h2>Advanced Topics</h2>

<h4>MessageHandler</h4>

<p>In some environments - specifically iOS apps and VSCode - you will want to get document state changes and other messages at a lower level than the MarkupDelegate. That level is the <em>MessageHandler</em>. The MarkupEditor’s default MessageHandler receives and processes <code>postMessage</code> as the document state changes, which it then passes-on to the MarkupDelegate (if the delegate exists and if the callback method exists in the delegate). Most developers will probably not even be aware that the MessageHandler exists. The MarkupDelegate callbacks will be sufficient for most developers.</p>

<p>The MessageHandler responds to the same kind of messages as the MarkupDelegate, but it sometimes does its own processing before informing the MarkupDelegate of the specific state change. For example, in the case of “ready”, the MessageHandler loads the initial HTML that was provided in the configuration or retrieves the contents of the filename, and then it loads that HTML into the document.</p>

<pre><code>postMessage(message) {
    let config = this.markupEditor.config
    let delegate = config.delegate

    switch (message) {
        // The editor posts `ready` when all scripts are loaded, so we can set the HTML. If HTML
        // is an empty document, then the config.placeholder will be shown.
        case 'ready':
            this.loadContents(config)
            delegate?.markupReady && delegate?.markupReady(this.markupEditor)
            return
        ... more cases
    }
...
}</code></pre>

<p>By the time your <code>delegate</code> receives <code>markupReady</code>, the document has been loaded and is ready to edit. This approach hides the complexity of fetching the file contents and dealing with failures. It reduces your input simply to providing a file name and avoids the MarkupDelegate having to decipher message types like the MessageHandler does.</p>

<p>For environments like iOS or VSCode, and perhaps others, you should set the MarkupEditor’s MessageHandler to one that is appropriate for the specific environment using <code>MU.setMessageHandler</code>. When you do that, <em>your MessageHandler is responsible for everything that the default MarkupEditor MessageHandler does</em>. For example, if you don’t load the <code>html</code> or <code>filename</code> contents when you receive the “ready” message, then nothing will show up in the editor.</p>

<h5>VSCode</h5>

<p>In VSCode, you would set the MessageHandler like this:</p>

<pre><code>vscode = acquireVsCodeApi();
MU.setMessageHandler(vscode);</code></pre>

<p>Now when the MarkupEditor executes its callbacks about document state changes (which it does in a VSCode WebviewPanel using <code>messageHandler?.postMessage(message)</code>), the <code>messageHandler</code> is <code>vscode</code>. When we created the VSCode WebviewPanel, we told it how to respond to messages:</p>

<pre><code>// Set up the message handler for messages coming from the webview
webviewPanel.webview.onDidReceiveMessage(this.handleMessage.bind(this));</code></pre>

<p>The messages in VSCode are JSON objects that include a <code>command</code> property which contains the message sent by the MarkupEditor callback.</p>

<p>You can review the source code for the <a href="https://github.com/stevengharris/markupeditor-vs">MarkupEditor VSCode extension</a> project for more details. Its MarkupCoordinator does the setup of the WebviewPanel, loading the MarkupEditor and dealing with the callbacks.</p>

<h5>UIKit and SwiftUI</h5>

<p>In an iOS project, you don’t have to set the MessageHandler explicitly, because the MarkupEditor sets it to <code>window.webkit?.messageHandlers?.markup</code> by default. This handy bit of legacy for iOS (and Mac Catalyst) developers exists because the MarkupEditor emerged first for Swift developers looking for WYSIWYG editing functionality.</p>

<p>In Swift, the MarkupEditor is embedded in a WKWebView. When <code>messageHandler?.postMessage(message)</code> is invoked, the message is handled by the WKScriptMessageHandler. The WKScriptMessageHandler for the Swift MarkupEditor is an instance of MarkupCoordinator, and messages are received in u<code>serContentController(_:didReceive:).</code></p>

<p>One other detail of the Swift MarkupEditor is that the toolbar is entirely implemented in SwiftUI. It uses the MarkupEditor with <code>ToolbarConfig.visibility.toolbar = false</code>. When the SwiftUI toolbar buttons are pressed, they directly invoke the MarkupEditor functionality using WKWebView’s <code>executeJavaScript</code> function.</p>

<p>You can review the source code and README for the <a href="https://github.com/stevengharris/MarkupEditor">Swift MarkupEditor</a> project for more details.</p>

<p></p>