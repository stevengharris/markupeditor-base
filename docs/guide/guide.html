<h1>MarkupEditor Developer's Guide</h1>

<h2>Contents</h2>

<blockquote>
    <p><a href="#concepts">Concepts</a></p>
    <blockquote>
        <p><a href="#goals-and-non-goals">Goals and Non-Goals</a></p>
    </blockquote>
    <p><a href="#essentials">Essentials</a></p>
    <blockquote>
        <p><a href="#using-the-markupeditor-in-a-browser">Using the MarkupEditor in a Browser</a></p>
        <p><a href="#using-the-markupeditor-in-node.js">Using the MarkupEditor in Node.js</a></p>
    </blockquote>
    <p><a href="#configuration">Configuration</a></p>
    <blockquote>
        <p><a href="#configuration-classes">Configuration Classes</a></p>
        <p><a href="#toolbarconfig">ToolbarConfig</a></p>
        <p><a href="#keymapconfig">KeymapConfig</a></p>
        <p><a href="#behaviorconfig">BehaviorConfig</a></p>
    </blockquote>
    <p><a href="#extending-the-toolbar">Extending the Toolbar</a></p>
    <p><a href="#communicating-with-the-markupeditor">Communicating with the MarkupEditor</a></p>
    <blockquote>
        <p><a href="#getting-and-setting-markupeditor-content">Getting and Setting MarkupEditor Contents</a></p>
        <p><a href="#markupdelegate">MarkupDelegate</a></p>
        <p><a href="#round-trip-from-the-markupeditor">Round-Trip from the MarkupEditor</a></p>
    </blockquote>
    <p><a href="#testing">Testing</a></p>
    <blockquote>
        <p><a href="#test-organization">Test Organization</a></p>
        <p><a href="#htmltest">HtmlTest</a></p>
        <p><a href="#running-tests">Running Tests</a></p>
    </blockquote>
    <p><a href="#advanced-topics">Advanced Topics</a></p>
    <blockquote>
        <p><a href="#messagehandler">MessageHandler</a></p>
        <p><a href="#markupeditor-project-structure">MarkupEditor Project Structure</a></p>
    </blockquote>
</blockquote>

<h2 id="concepts">Concepts</h2>

<p>The MarkupEditor in its “base” form is a what-you-see-is-what-you-get (<em>WYSIWYG</em>) editor meant to be embedded in an application of some kind. It comes with a configurable and extensible toolbar that provides UI access to its underlying editing functionality. The document you edit with the MarkupEditor is standard HTML with a limited set of supported tags. The document is styled using CSS, which you can override and supplement. As you edit the HTML document, the editor lets you know when changes occur, so you can take action based on your specific application context.</p>

<p>The <em>application environment</em> you’re building-for needs to support a web view, so you can load the MarkupEditor script and use the CSS styling that comes with it. We’re using the nebulous term “application environment” in this document, because that could be <em>Node.js</em> or <em>Electron</em> or <em>MacOS AppKit</em> or <em>iOS SwiftUI</em> or… the list goes on. The language you’re writing your application in could be JavaScript or any other language, as long as the application environment supports a web view and the mechanics of communicating to/from the web view and the MarkupEditor within it.</p>

<h3 id="goals-and-non-goals">Goals and Non-Goals</h3>

<p>A key goal of the MarkupEditor is that application developers be able to embed WYSIWYG editing functionality in any environment. They should be able to customize the editor’s appearance and behavior without having to fork the <a href="https://github.com/stevengharris/markupeditor-base">code</a>, or even having to learn much beyond how to get and set the HTML being edited. The MarkupEditor’s scope resembles and is by-design limited to Markdown’s scope. It doesn’t provide any direct support for fonts and styles, positioning text on a page, and other elaborate formatting. Like Markdown, it only supports the limited set of features you need to organize what you’re writing to get your points across effectively. It does not support import/export from/to Markdown or any other document formats. Since a MarkupEditor document consists of standard “clean” HTML without embedded styles or classes, there is an entire world of tools you can use to parse a MarkupEditor document, save it, search it, and export it. If you do transform the MarkupEditor’s clean HTML to some other form, like Markdown, just be aware that what you see in the MarkupEditor may not be what your end-users get.</p>

<h2 id="essentials">Essentials</h2>

<p>Let’s take a look at what is required for WYSIWYG editing directly in your web browser or using Node.js. These “essentials” are common to other environments that the MarkupEditor can be used in.</p>

<h3 id="using-the-markupeditor-in-a-browser">Using the MarkupEditor in a Browser</h3>

<p>By our nebulous definition, a web browser provides an application environment. Here’s an <a href="https://stevengharris.github.io/markupeditor-base/helloworld/index.html"><code>index.html</code></a> you can load in your browser to display an editable version of “Hello, world!”:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
    &lt;head&gt;
        &lt;title&gt;Hello MarkupEditor&lt;/title&gt;
        &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
        &lt;link href="../styles/markupeditor.css" rel="stylesheet"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="editor"&gt;&lt;/div&gt;
        &lt;script src="../src/markupeditor.umd.js"&gt;&lt;/script&gt;
        &lt;script&gt;
            new MU.MarkupEditor(document.querySelector('#editor'), {html: '&lt;h1&gt;Hello, world!&lt;/h1&gt;'})
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>The essentials involve:</p>

<ol>
    <li>
        <p>Linking to the MarkupEditor style sheets that are gathered together in <code>markupeditor.css</code>.</p>
    </li>
    <li>
        <p>Creating an empty <code>editor</code> div to edit in.</p>
    </li>
    <li>
        <p>Loading the MarkupEditor script <code>markupeditor.umd.js</code> which exposes its public API in a global, <code>MU</code>.</p>
    </li>
    <li>
        <p>Creating an instance of the MarkupEditor in the editor element, and in this case providing its initial HTML.</p>
    </li>
</ol>

<p>These essentials are common whenever you use the MarkupEditor, but the details will vary.</p>

<p><img src="c4f425be-396a-40b0-a219-4e599b921872.png" width="432" height="237"></p>

<p>Above, you see the result in the Vivaldi browser. Note the default toolbar shows up without any work on your part. The MarkupEditor lets you edit the document, but there is a very security-limited set of things you can do from a browser. While the browser is pretty much the simplest possible environment to use the MarkupEditor in, it also provides access to an array of development tools for debugging.</p>

<blockquote>
    <p><strong>Note</strong>: If you encounter a MarkupEditor bug, providing a test or usage flow that reproduces the bug in a browser will ensure it can be debugged with no setup barriers, increasing the likelihood of it being worked on.</p>
</blockquote>

<h3 id="using-the-markupeditor-in-node.js">Using the MarkupEditor in Node.js</h3>

<p>When you use the MarkupEditor in Node.js, you get access to the file system, among other things. In concrete terms, this means you can fetch file contents without the requirement that the access be gated by a trusted user action, as is required in the browser. The MarkupEditor lets you identify a <code>filename</code> containing the HTML contents it will show. Here’s how the contents of <code>guide.html</code> (which you’re reading now) are loaded into the MarkupEditor:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;title&gt;docs/demo/demo.html&lt;/title&gt;
    &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link href="styles/markupeditor.css" rel="stylesheet"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="editor"&gt;&lt;/div&gt;
    &lt;script src="dist/markupeditor.umd.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      new MU.MarkupEditor(document.querySelector('#editor'), {filename: "docs/guide/guide.html", base: "docs/guide/"})
    &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>

<p>Note that if you saved the HTML shown above as a file and attempted to load it in your browser, say by double-clicking on the file, it would fail with <code>Failed to load docs/guide/guide.html</code>. You would see the toolbar show up, but the browser fails when fetching <code>guide.html</code>. You can, however, do it with Node.js! Here is a script, <code>guide.js</code>, that can be executed using <code>node guide.js</code>:</p>

<pre><code>const express = require('express');

const app = express();

// Allow the relative references for css and scripts to work
app.use(express.static(`${__dirname}`, { index: false }))

// For parsing application/json
app.use(express.json())

// Load when loading http://localhost:${port}
app.get('/', (req, res) =&gt; {
  res.send(
    `
      &lt;!DOCTYPE html&gt;
      &lt;html lang="en"&gt;
        &lt;head&gt;
          &lt;title&gt;docs/demo/demo.html&lt;/title&gt;
          &lt;meta name="viewport" charset="utf-8" content="width=device-width, initial-scale=1.0"&gt;
          &lt;link href="styles/markupeditor.css" rel="stylesheet"&gt;
        &lt;/head&gt;
        &lt;body&gt;
          &lt;div id="editor"&gt;&lt;/div&gt;
          &lt;script src="dist/markupeditor.umd.js"&gt;&lt;/script&gt;
          &lt;script&gt;
            new MU.MarkupEditor(document.querySelector('#editor'), {filename: "docs/guide/guide.html", base: "docs/guide/"})
          &lt;/script&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    `
  )
});

app.listen('3000', () =&gt; {
  console.log(`Server listening at http://localhost:3000`);
});</code></pre>

<p>Here we use <a href="https://expressjs.com">Express</a> to respond with the HTML we showed earlier when you open your browser on <code>http://localhost:3000</code>. Note that <code>base</code> is passed as part of the MarkupEditor configuration. Under the covers, this ends up adding an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/base">HTML base element</a> to the document, so that the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/img"><code>img src</code></a> attribute and other references in the document are specified relative to the HTML document being edited.</p>

<p>There is a more robust version of this script - <a href="https://github.com/stevengharris/markupeditor-base">markupeditor.js</a> in the markupeditor-base project - that you can execute from anywhere, identifying the HTML file to open (or none if you just want an empty document) and the port to listen on. For example:</p>

<pre><code>$ node markupeditor.js docs/demo/demo.html --port 8000
Server listening at http://localhost:8000</code></pre>

<p>The MarkupEditor documentation, including this Developer’s Guide, is hosted using GitHub Pages. You can use npm/node to view the docs locally using:</p>

<pre><code>$ npm run docs

&gt; markupeditor-base@0.8.0 predocs
&gt; sh predocs.sh

Updating ./docs dependencies...
cp -f ./dist/markupeditor.umd.js ./docs/src/markupeditor.umd.js
cp -f ./styles/markupeditor.css ./docs/styles/markupeditor.css
cp -f ./styles/markup.css ./docs/styles/markup.css
cp -f ./styles/mirror.css ./docs/styles/mirror.css
cp -f ./styles/toolbar.css ./docs/styles/toolbar.css

&gt; markupeditor-base@0.8.0 docs
&gt; node ./docs/index.js

Server listening at http://localhost:3000</code></pre>

<p>Besides invoking node on the <code>index.js</code> in the docs directory, the script runs a “predocs” step that copies the required MarkupEditor files into locations in the docs directory. When the changes are pushed to GitHub, it kicks off a refresh of the <a href="https://stevengharris.github.io/markupeditor-base/">project web site</a>. This process makes for a nice closed loop — edit the project web site contents locally using the MarkupEditor, and then update the site when the changes are pushed to GitHub.</p>

<p>This is the extent of “application environments” that are supported out-of-the-box when you install the MarkupEditor base project. It’s the minimum needed to develop and debug the MarkupEditor in its base form. The MarkupEditor can, however, be embedded in other environments. Before we cover that, let’s cover configuration, how you use the MarkupEditor API, and how to hook into the notifications it provides as you edit a document.</p>

<h2 id="configuration">Configuration</h2>

<p>So far, we have seen how to pass some initial HTML to the MarkupEditor, and how to identify a <code>filename</code> to open using Node.js. When you want to call into the MarkupEditor, you do that by invoking the public API exposed via the <code>MU</code> object. We saw <code>MU</code> used earlier when we created an instance of MarkupEditor using <code>new MU.MarkupEditor(&lt;target div&gt;, &lt;config&gt;)</code>. Let’s examine the configuration passed when the MarkupEditor instance is created.</p>

<h3 id="configuration-classes">Configuration Classes</h3>

<p>There are three configuration classes:</p>

<ul>
    <li>
        <p><code>ToolbarConfig</code> specifies whether the toolbar itself is visible, which sub-toolbars/dropdowns are visible, and which items are included in each. Refer to <code>src/setup/toolbarconfig.js</code>.</p>
    </li>
    <li>
        <p><code>KeymapConfig</code> specifies how editing actions map to key combos (aka hotkeys). Refer to <code>src/setup/keymapconfig.js</code>.</p>
    </li>
    <li>
        <p><code>BehaviorConfig</code> specifies various ways the MarkupEditor behaves that are not specific to the menu/toolbar or keymap configurations. Refer to <code>src/setup/behaviorconfig.js</code>.</p>
    </li>
</ul>

<p>You can view the full set of options in each configuration class in the <a href="https://stevengharris.github.io/markupeditor-base/api/index.html">MarkupEditor API</a> documentation. Each config provides a <code>standard()</code> static function that returns the default configuration used by the MarkupEditor when you don’t specify a configuration. Note that <code>ToolbarConfig</code> is independent of <code>KeymapConfig</code> because, for example, while you may <em>not</em> want to display undo and redo buttons in the toolbar, you <em>will</em> want to map them to hotkeys like <code>Cmd+S</code> and <code>Shift+Cmd+S</code> (the default in both cases).</p>

<p>A simple way to customize configuration is to use one of the pre-defined static methods to get a config object back. You can then modify that config object as needed. Going all the way back to our “Hello, world!” example, we could add the undo/redo buttons in by making the correction sub-toolbar visible, turn off the ability for users to insert tables, and we could change the hotkey used for adding a link:</p>

<pre><code>&lt;script&gt;
    let toolbarConfig = MU.ToolbarConfig.standard(true)   // The standard toolbar but with undo/redo showing
    toolbarConfig.insertBar.table = false;                // Turn off table insert
    let keymapConfig = MU.KeymapConfig.standard();        // Grab the standard keymap config as a baseline
    keymapConfig.link = ["Ctrl-L", "Ctrl-l"];             // Use Control+L instead of Command+k
    new MU.MarkupEditor(
        document.querySelector('#editor'), {
            html: '&lt;h1&gt;Hello, world!&lt;/h1&gt;',
            toolbar: toolbarConfig,
            keymap: keymapConfig,
            placeholder: "&lt;p&gt;Edit document...&lt;/p&gt;"
        }
    )
&lt;/script&gt;</code></pre>

<p>Besides the <code>html</code>, <code>filename</code>, <code>toolbar</code>, <code>keymap</code>, and <code>behavior</code> properties, you can also pass <code>placeholder</code> html to show when the document is empty. Let’s take a closer look at each of the configuration classes.</p>

<h3 id="toolbarconfig">ToolbarConfig</h3>

<p>The ToolbarConfig is easier to explain with a picture, because it refers to various pieces of the toolbar by name, and the names make more sense when you can see the toolbar. Here is the full toolbar in all its glory. This toolbar was obtained by defining <code>toolbarConfig = MU.ToolbarConfig.full(true)</code> and then passing <code>toolbar: toolbarConfig</code> in the MarkupEditor configuration. (The <code>true</code> argument specifies that undo/redo should be visible in the <code>full</code> toolbar.) Note that the <code>ToolbarConfig.standard()</code> does not display undo/redo, underline, and subscript/superscript.</p>

<p><img src="69ac24ab-f2b9-4e61-b9fa-a2320719475f.png" width="825" height="148"></p>

<h4>Visibility</h4>

<p>You can control the visibility of each of the individual bars and menus by name; for example, <code>toolbarConfig.visibility.correctionBar = false</code> or <code>toolbarConfig.visibility.search = false.</code> Within the bars and menus, you can also control what is visible. For example, <code>toolbarConfig.insertBar.table = false</code> will remove the <em>tableMenu</em>. Within the <em>tableMenu</em>, you can control whether it includes a <em>Header</em> or <em>Border</em> item. The individual controls are itemized with comments in <code>src/setup/toolbarconfig.js</code>. It’s also possible to turn off the overall toolbar using <code>toolbarConfig.visibility.toolbar = false</code>. This is useful when you define your own toolbar, something that is done in the <a href="https://github.com/stevengharris/MarkupEditor">Swift MarkupEditor</a>.</p>

<h4>Size</h4>

<p>The toolbar attempts to conform to Apple’s Human Interface Guidelines in terms of size. It scales properly with zoom-in and zoom-out, but is not resizable by configuration. You could adjust or override the settings in s<code>tyles/toolbar.css</code> if needed. Note that the toolbar autosizes to fit within the containing element width using a <code>…</code> (aka “More” button) on the right when the total item width is too large to fit. Pressing the More button will expose the missing elements using a sub-toolbar. The toolbar responds to resizing events, so window resizing (or device rotation) will re-evaluate whether the More button is needed to accommodate the contents.</p>

<h4>Style Visibility and Names</h4>

<p>The names in the <em>styleMenu</em> can be set as part of the ToolbarConfig. For example, to use “Normal” for the &lt;P&gt; element rather than “Body”, you would specify <code>toolbarConfig.styleMenu.p = “Normal”</code>. If you want to remove an item, set its value to <code>null</code>. For example, <code>toolbarConfig.style.pre = null</code> will remove the <em>Code</em> item from the <em>styleMenu</em> (because code blocks are <code>&lt;pre&gt;&lt;code&gt;</code> in the HTML).</p>

<h4>Ordering</h4>

<p>You can re-order the toolbar items using <code>toolbarConfig.ordering</code>. The default values in ascending order left to right go from 10 for the <code>correctionBar</code>, 60 for <code>search</code>. So, for example, you could put the <code>formatBar</code> between the <code>correctionBar</code> and <code>insertBar</code> using <code>toolbarConfig.ordering.formatBar = 15</code>. The ordering of items within the individual bars and menus is not configurable.</p>

<h4>Icons</h4>

<p>The toolbar icons are not currently configurable. Toolbar icons are from <a href="https://fonts.google.com/icons">Google’s Material Design Icons</a> set and downloaded as SVG from that site. The SVG definitions are in <code>src/setup/icons.js</code>. You can extend the toolbar by prepending or appending a custom group of icons and attaching commands to them.</p>

<h3 id="keymapconfig">KeymapConfig</h3>

<p>The KeymapConfig follows <a href="https://github.com/ProseMirror/prosemirror-keymap">ProseMirror conventions</a>. To quote the comments from <a href="https://github.com/ProseMirror/prosemirror-keymap/blob/081f24f65b6a394174a4bdf07b9a55a00361f1b7/src/keymap.ts">keymap.ts</a>…</p>

<blockquote>
    <pre><code>/// Key names may be strings like `"Shift-Ctrl-Enter"`—a key
/// identifier prefixed with zero or more modifiers. Key identifiers
/// are based on the strings that can appear in
/// [`KeyEvent.key`](https:///developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
/// Use lowercase letters to refer to letter keys (or uppercase letters
/// if you want shift to be held). You may use `"Space"` as an alias
/// for the `" "` name.
///
/// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
/// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
/// `Meta-`) are recognized. For characters that are created by holding
/// shift, the `Shift-` prefix is implied, and should not be added
/// explicitly.
///
/// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
/// other platforms.
///
/// You can add multiple keymap plugins to an editor. The order in
/// which they appear determines their precedence (the ones early in
/// the array get to dispatch first).</code></pre>
</blockquote>

<p>It’s likely that the hotkeys you want to use are specific to your application environment. (In fact, some of the <code>standard()</code> defaults conflict with web browser navigation defaults.) In the end, there is no right way for a library to set up key bindings, so you should make sure they are set up as you want. As noted earlier, the ToolbarConfig and KeymapConfig are independent, but by default only the key mappings for visible toolbar elements are set up. Undo and redo are the exceptions to this rule and are always set up whether the <code>correctionBar</code> is visible or not. The <code>desktop()</code> KeymapConfig settings are useful for a desktop app, since they include all mappings that can then be used to set up a menu independently of the toolbar, something that is used in the <a href="https://github.com/stevengharris/markupeditor-desktop">MarkupEditor desktop</a> version.</p>

<h3 id="behaviorconfig">BehaviorConfig</h3>

<p>A common and simple case for BehaviorConfig is to control whether the editor takes focus after it loads. Sometimes you want to be able to type immediately, and other times you want your user to click in the editor before typing. You can control this behavior by setting <code>focusAfterLoad</code> to <code>true</code> (the default) or <code>false</code>. The other options in BehaviorConfig are for more advanced usage and are discussed in more detail later:</p>

<ul>
    <li>
        <p><strong>selectImage</strong>: Whether to show a "Select..." button in the Insert Image dialog. You need access to the file system and facilities of the application environment the MarkupEditor is embedded in.</p>
    </li>
    <li>
        <p><strong>insertLink</strong>: Whether to defer to the MarkupDelegate rather than use the default LinkDialog. You can replace the default LinkDialog used to insert and edit links with your own by implementing <code>markupInsertLink</code> in your MarkupDelegate.</p>
    </li>
    <li>
        <p><strong>insertImage</strong>: Whether to defer to the MarkupDelegate rather than use the default ImageDialog. You can replace the default ImageDialog used to insert and edit images with your own by implementing <code>markupInsertImage</code> in your MarkupDelegate.</p>
    </li>
</ul>

<h2 id="extending-the-toolbar">Extending the Toolbar</h2>

<p>You can prepend and append your own toolbar to the MarkupEditor toolbar you have configured. For more detail, take a look at the MarkupEditor Demo in the <code>docs/demo</code> directory. The intent of the demo to provide a document that contains all the elements supported in the MarkupEditor, and to describe how to use the editor. But, to make the demo more useful, even in a browser, it was helpful to provide some tools beyond the default toolbar. This is done by prepending a DemoToolbar:</p>

<p><img src="cfa35165-ae8d-4b01-8058-85d29cc18aeb.png" width="790" height="107"></p>

<p>Here is part of the demotoolbar.js code used to create the DemoToolbar…</p>

<pre><code>/** A class holding the command items and functionality for a File toolbar that is prepended to the MarkupEditor toolbar */
class DemoToolbar {
  constructor() { 
    this.menuItems = this.buildMenuItems()
  }

  /** SVG defining icons by key, obtained from https://fonts.google.com/icons under https://openfontlicense.org license. */
  icons = {
    new: {
      // &lt;span class="material-symbols-outlined"&gt;note_add&lt;/span&gt;
      svg: '&lt;svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"&gt;&lt;path d="M440-240h80v-120h120v-80H520v-120h-80v120H320v80h120v120ZM240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v480q0 33-23.5 56.5T720-80H240Zm280-520v-200H240v640h480v-440H520ZM240-800v200-200 640-640Z"/&gt;&lt;/svg&gt;'
    },
    open: {
      // &lt;span class="material-symbols-outlined"&gt;file_open&lt;/span&gt;
      svg: '&lt;svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"&gt;&lt;path d="M240-80q-33 0-56.5-23.5T160-160v-640q0-33 23.5-56.5T240-880h320l240 240v240h-80v-200H520v-200H240v640h360v80H240Zm638 15L760-183v89h-80v-226h226v80h-90l118 118-56 57Zm-638-95v-640 640Z"/&gt;&lt;/svg&gt;'
    },
    html: {
      // &lt;span class="material-symbols-outlined"&gt;html&lt;/span&gt;
      svg: '&lt;svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"&gt;&lt;path d="M0-360v-240h60v80h80v-80h60v240h-60v-100H60v100H0Zm310 0v-180h-70v-60h200v60h-70v180h-60Zm170 0v-200q0-17 11.5-28.5T520-600h180q17 0 28.5 11.5T740-560v200h-60v-180h-40v140h-60v-140h-40v180h-60Zm320 0v-240h60v180h100v60H800Z"/&gt;&lt;/svg&gt;'
    },
    copy: {
      // &lt;span class="material-symbols-outlined"&gt;file_copy&lt;/span&gt;
      svg: '&lt;svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#1f1f1f"&gt;&lt;path d="M744-192H312q-29 0-50.5-21.5T240-264v-576q0-29 21.5-50.5T312-912h312l192 192v456q0 29-21.5 50.5T744-192ZM576-672v-168H312v576h432v-408H576ZM168-48q-29 0-50.5-21.5T96-120v-552h72v552h456v72H168Zm144-792v195-195 576-576Z"/&gt;&lt;/svg&gt;'
    }
  }

  /** Return an array of MenuItems */
  buildMenuItems() {
    let newItem = MU.cmdItem(
      this.newDocument.bind(this),
      {
        enable: () =&gt; { return true },
        title: 'New document',
        icon: this.icons.new
      }
    )
    let openItem = MU.cmdItem(
      this.openDocument.bind(this),
      {
        enable: () =&gt; { return true },
        title: 'Open document',
        icon: this.icons.open
      }
    )
    let htmlItem = MU.cmdItem(
      this.toggleRaw.bind(this),
      {
        enable: () =&gt; { return true },
        title: 'Show HTML',
        icon: this.icons.html
      }
    )
    let copyItem = MU.cmdItem(
      this.copyRaw.bind(this),
      {
        enable: () =&gt; { return true },
        title: 'Copy HTML',
        icon: this.icons.copy
      }
    )
    return [newItem, openItem, htmlItem, copyItem]
  }

  newDocument() {
    MU.emptyDocument()
    this.updateRaw()
  }

  // ... more code ...
}</code></pre>

<p>The code will be loaded as a script and has access to the global <code>MU</code> to execute MarkupEditor functionality. When we instantiate the DemoToolbar, we set up <code>menuItems</code>, an array of MenuItem instances, each of which is created using the <code>MU.cmdItem</code> function. The <code>MU.cmdItem</code> function takes a command/function as its first argument along with options that define when the MenuItem should be enabled, what to use as a title when hovering over it, and what to display as its icon. The icons are defined using SVG taken from Google’s <a href="https://fonts.google.com/icons">Material Design Icon set</a>. For the one function included in the snippet above, <code>newDocument</code>, we use the <code>MU.emptyDocument()</code> function and then update the demo’s “raw HTML” that allows the user to see the underlying HTML as it changes.</p>

<p>In the <code>index.html</code> that loads the demo, we load the <code>demotoolbar.js</code> script, and then after creating the MarkupEditor instance, we create a DemoToolbar instance and prepend its menu items:</p>

<pre><code>&lt;script src="src/demotoolbar.js"&gt;&lt;/script&gt;
&lt;script&gt;
    const markupEditor = new MU.MarkupEditor(
        document.querySelector('#editor'),
        {
            delegate: new DemoDelegate(),
            placeholder: 'Edit document...',
            filename: 'demo.html',
        }
    )
    // Instantiate the DemoToolbar and place its `menuItems` at the front of the toolbar.
    const demoToolbar = new DemoToolbar()
    MU.prependToolbar(demoToolbar.menuItems)
&lt;/script&gt;</code></pre>

<p>In addition to <code>prependToolbar</code> and <code>appendToolbar</code>, the key elements and functions used to create the MarkupEditor toolbar are available to you to create your own, including:</p>

<ul>
    <li>
        <p>MenuItem</p>
    </li>
    <li>
        <p>Dropdown</p>
    </li>
    <li>
        <p>DropdownSubmenu</p>
    </li>
    <li>
        <p>cmdItem</p>
    </li>
    <li>
        <p>renderGrouped,</p>
    </li>
    <li>
        <p>renderDropdownItems</p>
    </li>
</ul>

<p>The <code>toolbarView</code> itself is also available to you if needed. Refer to the code in the MarkupEditor Demo and in the MarkupEditor itself to learn more about how a toolbar and its MenuItems and Dropdowns are built.</p>

<h2 id="communicating-with-the-markupeditor">Communicating with the MarkupEditor</h2>

<p>It’s important to recognize <em>where</em> your code is executing when using the MarkupEditor. In the examples we’ve shown so far, we are executing a script that is running inside of the web view itself. The global <code>MU</code> was created when you loaded <code>markupeditor.umd.js</code> earlier, so it’s available for you to reference directly in any script you load <em>after</em> <code>markupeditor.umd.js</code>. When you are executing in the application environment process you used to create and hold the web view, like Node.js or an iOS app, you will have to access <code>MU</code> with a call to something like <code>executeJavaScript</code>. We will cover that a little later.</p>

<h3 id="getting-and-setting-markupeditor-content">Getting and Setting MarkupEditor Contents</h3>

<p>We’ve see how to set up the initial HTML when you create a MarkupEditor instance in a web view by passing <code>html</code> or <code>filename</code> as part of its configuration. If your environment provides access to the file system and perhaps platform-native dialogs for selecting a file, you will want to get the MarkupEditor contents to save to the file, or set the MarkupEditor contents from the file contents. To get the MarkupEditor contents:</p>

<pre><code>let contents = MU.getHTML()</code></pre>

<p>and to set the contents to an HTML string called <code>htmlString</code>:</p>

<pre><code>MU.setHTML(htmlString)</code></pre>

<h4>HTML Restrictions</h4>

<p>The MarkupEditor uses the following HTML elements:</p>

<ul>
    <li>
        <p>Paragraph Styles: <code>&lt;H1&gt;</code>, <code>&lt;H2&gt;</code>, <code>&lt;H3&gt;</code>, <code>&lt;H4&gt;</code>, <code>&lt;H5&gt;</code>, <code>&lt;H6&gt;</code>, <code>&lt;P&gt;</code>. <code>&lt;P&gt;</code> is the default style, also referred to as "Body" in various places. The <code>&lt;CODE&gt;</code> element is supported as a paragraph style or an inlined format. When used as a paragraph style, it is output as <code>&lt;PRE&gt;&lt;CODE&gt;</code> to preserve its exact form.</p>
    </li>
    <li>
        <p>Formatting: <code>&lt;STRONG&gt;</code>, <code>&lt;EM&gt;</code>, <code>&lt;U&gt;</code>, <code>&lt;CODE&gt;</code>, <code>&lt;S&gt;</code>, <code>&lt;SUB&gt;</code>, <code>&lt;SUP&gt;</code>.</p>
    </li>
    <li>
        <p>Images: <code>&lt;IMG&gt;</code>.</p>
    </li>
    <li>
        <p>Links: <code>&lt;A&gt;</code>.</p>
    </li>
    <li>
        <p>Lists: <code>&lt;UL&gt;</code>, <code>&lt;OL&gt;</code>, <code>&lt;LI&gt;</code>.</p>
    </li>
    <li>
        <p>Tables: <code>&lt;TABLE&gt;</code>, <code>&lt;TR&gt;</code>, <code>&lt;TH&gt;</code>, <code>&lt;TD&gt;</code>.</p>
    </li>
    <li>
        <p>Indenting: <code>&lt;BLOCKQUOTE&gt;</code>.</p>
    </li>
</ul>

<p>When you use <code>setHTML</code> or paste HTML content into the MarkupEditor, it will ignore any elements that do not correspond to these tags. The MarkupEditor will automatically convert <code>&lt;B&gt;</code> to <code>&lt;STRONG&gt;</code>, <code>&lt;I&gt;</code> to <code>&lt;EM&gt;</code>, and <code>&lt;DEL&gt;</code> to <code>&lt;S&gt;</code>. It will also convert some styling, like <code>font-style=italic</code> to the corresponding HTML element. The end result is that you can’t break the MarkupEditor by pasting or setting arbitrary HTML, but it will ingest only what it can display properly and that you can properly edit.</p>

<p>To learn more about how the MarkupEditor interprets incoming HTML and outputs HTML, look at <code>src/schema/index.js</code> in the <a href="https://github.com/stevengharris/markupeditor-base">project repository</a>, and read about <a href="https://prosemirror.net">ProseMirror</a>, which is doing all the heavy lifting behind the scenes.</p>

<h3 id="markupdelegate">MarkupDelegate</h3>

<p>The MarkupEditor makes callbacks to a delegate, aka the <em>MarkupDelegate</em>, as you edit the document and its state changes. You can view the full of set callbacks in the <a href="https://stevengharris.github.io/markupeditor-base/api/index.html">MarkupEditor API</a>. Let’s take a look at how to set up your MarkupDelegate and make use of the callbacks.</p>

<p>Here’s a simple MarkupDelegate. We can put it in a <code>mydelegate.js</code> file and then load it via a script. Its methods will be called when the MarkupEditor is “ready” and when you type into the document or otherwise make editing changes:</p>

<pre><code>class MarkupDelegate {

    // Do something in your app when all scripts are loaded and it's ready.
    markupReady() {
        // For now, just log...
        console.log('The MarkupEditor is ready')
    }

    // Do something in your app when the document receives input from typing or pasting, etc.
    // For example, you might track changes to enable an auto-save feature.
    markupInput() {
        // For now, just log...
        console.log('The MarkupEditor received input')
    }
}</code></pre>

<p>You can load the script and pass the MarkupDelegate instance to the MarkupEditor. Here is what it would look like to load a <code>demo.html</code> file and pass this delegate instance to the MarkupEditor:</p>

<pre><code>&lt;script src="../src/markupeditor.umd.js"&gt;&lt;/script&gt;
&lt;script src="src/mydelegate.js"&gt;&lt;/script&gt;
&lt;script&gt;
    const markupEditor = new MU.MarkupEditor(
        document.querySelector('#editor'), {
            delegate: new MarkupDelegate(),
            placeholder: 'Edit document...',
            filename: 'demo.html',
        }
    )
&lt;/script&gt;</code></pre>

<p>You can call your MarkupDelegate anything you want. The MarkupEditor will only invoke the callbacks if the delegate exists and the function is defined. For example, if you don’t define <code>markupInput</code>, it just won’t be called.</p>

<p>Again, the code in the MarkupDelegate above will execute in the web view. It has access to all of the MarkupEditor functionality via the <code>MU</code> global. Often, access to <code>MU</code> and its functionality will be all you’ll need. For example, the <a href="https://stevengharris.github.io/markupeditor-base/demo/index.html">MarkupEditor demo</a> uses <code>markupInput</code> to update the view of the “raw HTML” as the user edits the document. You can also use the MarkupDelegate to communicate with your application environment, but the mechanism for doing that will be specific to the application environment.</p>

<h3 id="round-trip-from-the-markupeditor">Round-Trip from the MarkupEditor</h3>

<p>At this point we have covered:</p>

<ul>
    <li>
        <p>How to set up up a web view containing the MarkupEditor and its associated scripts and styling.</p>
    </li>
    <li>
        <p>How to set up a web view containing the MarkupEditor in a Node.js server using Express.</p>
    </li>
    <li>
        <p>How to pass configuration options to the MarkupEditor.</p>
    </li>
    <li>
        <p>How to use a MarkupDelegate to receive notifications as the state changes in the document you’re editing.</p>
    </li>
    <li>
        <p>How to invoke MarkupEditor functionality from with the web view using the <code>MU</code> global.</p>
    </li>
</ul>

<p>What remains is how to access to your application environment, and then in turn, to invoke MarkupEditor functionality from your application environment. The “how” is specific to your environment. We will use a concrete example of selecting an image from the file system when using the MarkupEditor with Electron. The code will all be Electron-specific, but the concepts will be similar in other environments. Ultimately they all need to deal with <em>interprocess communication</em>.</p>

<h4>Selecting an Image</h4>

<p>If you enable “selectImage” in BehaviorConfig, the MarkupEditor shows a “Select…” button in the dialog for inserting images:</p>

<blockquote>
    <p><img src="d505d8fc-ea35-4736-a022-7f6e6a183f1e.png" width="244" height="112"></p>
</blockquote>

<p>Why even make “selectImage” an option? Because:</p>

<ul>
    <li>
        <p>You need access to the file system, which is dependent on your application environment.</p>
    </li>
    <li>
        <p>The MarkupEditor itself doesn’t know how to do this and has very restricted access to the file system.</p>
    </li>
    <li>
        <p>You may be using the MarkupEditor in an environment where you don’t want to allow image selection but still want to be able to insert images by URL.</p>
    </li>
    <li>
        <p>As an app developer, you take on a lot of issues when you allow local images to be inserted in your document. For example… What do you do with the image once you’ve selected it? Do you set your image <code>src</code> to the file itself, or do you encode the file data and embed it? If you point to the file, then what happens when you move your document around or the image file no longer exists? These are all the kinds of issues that separate a demo from a product!</p>
    </li>
</ul>

<p>When you hit the “Select…” button, the MarkupEditor closes the dialog and invokes <code>markupSelectImage</code> in your MarkupDelegate. Remember, your MarkupDelegate is executing in the web view and still has very restricted access to the file system. In the Electron app, your MarkupDelegate would look like this:</p>

<pre><code>class MarkupDelegate {

    markupSelectImage() {
        // Reference the definition in preload.js
        window.markupAPI.selectImage()
    }
}</code></pre>

<p>The <code>window.markupAPI</code> is defined in an <a href="https://www.electronjs.org/docs/latest/tutorial/tutorial-preload">Electron preload script</a> <code>preload.js</code>:</p>

<pre><code>const { contextBridge, ipcRenderer } = require('electron');

/** Define the markupAPI endpoints exposed via windowEvents in main.js */
contextBridge.exposeInMainWorld('markupAPI', {
    selectImage: () =&gt; { ipcRenderer.send('selectImage') },
});</code></pre>

<p>Meanwhile, in our Electron app’s <code>main.js</code>, when the app is ready, we set the app to respond to this new custom event, <code>selectImage</code>:</p>

<pre><code>ipcMain.on('selectImage', handleSelectImage)</code></pre>

<p>When the event is triggered, it will invoke our <code>handleSelectImage</code>. Finally(!!!) we can use Electron’s <code>showOpenDialog</code> to select the file with a native dialog and insert that image data into the MarkupEditor document:</p>

<pre><code>async function handleSelectImage() {
    const { canceled, filePaths } = await dialog.showOpenDialog({
        properties: ['openFile'],
        filters: [
            { name: 'Image', extensions: ['png', 'jpg', 'jpeg', 'gif'] }
        ]
    });

    if (!canceled) {
        let filePath = filePaths[0]
        fs.readFile(filePath, 'base64', (err, data) =&gt; {
            if (err) {
                console.error('Error reading file:', err);
                return;
            }
            let src = srcFromData(filePath, data)
            if (!src) {
                console.error('Unsupported media type')
                return
            }
            let insertImageCommand = `MU.insertImage("${src}")`
            getWebContents()?.executeJavaScript(insertImageCommand)
                .then(()=&gt;{console.log("Done insertImage")})
                .catch((error) =&gt; {
                    console.error('Error inserting image:', error);
                });
        });
    }
}</code></pre>

<p>We can then pass the data as the image <code>src</code> using <code>MU.insertImage</code>. At this point, though, we are executing in the Electron main process, not in the web view which is part of Electron’s renderer process. We have to invoke <code>MU.insertImage</code> using the Electron WebContents and its <code>executeJavaScript</code> method, passing the command to invoke in the web view along with the <code>src</code> data we got from the selected file. <code>MU.insertImage</code> inserts the image at the selection point and updates the document.</p>

<h4>Other Round-Trip Use Cases</h4>

<p>Two “insert” options in the MarkupEditor toolbar - insert link and image - involve user input of some kind. Each uses a MarkupEditor-supplied dialog with input fields that may or may not be appropriate in your application context. (The table insert operation is done using a drop-down menu, not a dialog.) Each dialog can be replaced with your own code without modifying the MarkupEditor itself. Do this by setting <code>insertLink</code> and/or <code>insertImage</code> to <code>true</code> in BehaviorConfig. If you do this with <code>insertLink</code>, your MarkupDelegate’s <code>markupInsertLink</code> method will be called instead of presenting the default LinkDialog. If you do this with <code>insertImage</code>, your MarkupDelegate’s <code>markupInsertImage</code> method will be called instead of presenting the default ImageDialog. If you are using Electron, you can base your implementation of these methods in your MarkupDelegate on the flow discussed above for <code>markupSelectImage</code>.</p>

<h4>More Electron Resources</h4>

<p>You can find the Electron-specific code discussed here in the source of the <a href="https://github.com/stevengharris/markupeditor-desktop">MarkupEditor Desktop app</a>. It supports local images and saves their contents to file at “save time” alongside the document being edited. The desktop app was used to edit this entire Developer’s Guide.</p>

<h2 id="testing">Testing</h2>

<p>The MarkupEditor includes over 200 <a href="https://jestjs.io">JEST</a>-based tests that exercise MarkupEditor functionality across a variety of conditions. Although the MarkupEditor uses ProseMirror, which has a large set of tests itself, the usage in the MarkupEditor can often be different. For example, indenting and outdenting in the MarkupEditor can be applied both to blocks like paragraphs, but also to lists. In lists, indent/outdent is interpreted as “wrap in a sublist” or “lift out of the list” whenever possible. Actions for selections across ranges of elements in the MarkupEditor document are also applied as much as possible. The goal when applying an action is to follow the <a href="https://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a> - the editor should behave like you expect. You can always <code>undo</code> if it doesn’t. However, if an editing action produces an unexpected or incorrect behavior, please file an issue with details, or submit a pull request with updates to the tests.</p>

<h3 id="test-organization">Test Organization</h3>

<p>The tests are in the <code>test</code> directory and are driven from a single <code>test.js</code> file. The tests are organized into a number of test suites, each one of which is defined using a JSON file. The JSON file definition makes it possible to share the test data in other environments, such as the Swift MarkupEditor, which uses a non-JavaScript test framework. Each JSON file contains an array that translates to instances of HtmlTest as defined in <code>htmltest.js</code>.</p>

<h3 id="htmltest">HtmlTest</h3>

<p>The primary function of an HtmlTest is to define the <code>description</code>, <code>startHtml</code>, <code>endHtml</code>, and the <code>action</code> that will be applied to it. For testing purposes, the <code>startHtml</code> and <code>endHtml</code> mark the selection using a single <code>sel</code> character (by default, a vertical bar: |). We can set the selection in the document based on <code>startHtml</code>, and we can ensure that the selection matches <code>endHtml</code> after applying the <code>action</code>. By default, <code>undo</code> and <code>redo</code> are also run after applying the <code>action</code>, with the test making sure results match <code>startHtml</code> and <code>endHtml</code> respectively. (There are some exceptional tests where <code>undoHtml</code> is defined separately from <code>startHtml</code>.) You can skip a test using <code>skipTest</code>, which will result in the test showing as “passed”, but the description will be prepended with “SKIPPED…” to make it visible. There are also flags to skip setting the initial HTML (<code>skipSet</code>) and undo/redo (<code>skipUndoRedo</code>) if needed.</p>

<p>The <code>action</code> and a single optional <code>arg</code> are translated into a JavaScript function using the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/Function">Function constructor</a>. The <code>MU</code> global can be referenced in your action string.</p>

<h3 id="running-tests">Running Tests</h3>

<p>The npm <code>test</code> script builds the MarkupEditor first, and then executes all the test suites.</p>

<pre><code>$ npm run test

&gt; markupeditor-base@0.8.4 pretest
&gt; npm run build


&gt; markupeditor-base@0.8.4 build
&gt; rollup -c


src/main.js → dist/markupeditor.umd.js...
created dist/markupeditor.umd.js in 338ms

src/main.js → dist/markupeditor.cjs.js, dist/markupeditor.esm.js...
created dist/markupeditor.cjs.js, dist/markupeditor.esm.js in 75ms

&gt; markupeditor-base@0.8.4 test
&gt; jest

Debugger listening on ws://127.0.0.1:50799/3467f93f-4c75-4c4e-925d-e59cd9d7d47a
For help, see: https://nodejs.org/en/docs/inspector
Debugger attached.
 PASS  test/test.js
  Ensure baseline behavior works as expected.
    ✓ Simple test (26 ms)
    ✓ Extract when selection begins in one styled list item, ends in another (21 ms)
    ✓ Extract when selection is in a table (10 ms)
  [... snipped out many other tests ...]
  Insert link at various locations.
    ✓ Link in P - Paste link at a fully-selected word (6 ms)
    ✓ Link in P - Paste link at end of a word (5 ms)
    ✓ Link in P - Paste link at beginning of a word (4 ms)
    ✓ Link in P - Paste link at beginning of paragraph (5 ms)
    ✓ Link in P - Paste link at end of paragraph (4 ms)
  Search forward and backward in various scenarios.
    ✓ Exact word match forward (4 ms)
    ✓ Exact word match backward (3 ms)
    ✓ Partial word match forward (3 ms)
    ✓ Partial word match backward (4 ms)
    ✓ Mixed case word match forward (4 ms)
    ✓ Mixed case word match backward (4 ms)
    ✓ Mixed case search forward for lowercase word (3 ms)
    ✓ Mixed case search backward for lowercase word (4 ms)
    ✓ Search forward with apostrophe (3 ms)
    ✓ Search backward with apostrophe (3 ms)
    ✓ Search forward with apostrophe and quotes (4 ms)
    ✓ Search backward with apostrophe and quotes (3 ms)
    ✓ Search forward with smart quotes (4 ms)
    ✓ Search backward with smart quotes (3 ms)
    ✓ Search forward with smart apostrophe (4 ms)
    ✓ Search backward with smart apostrophe (3 ms)
    ✓ Search forward with mixed smart apostrophe and quotes (4 ms)
    ✓ Search backward with mixed smart apostrophe and quotes (3 ms)
    ✓ Search forward relative to selection (3 ms)
    ✓ Search backward relative to selection (4 ms)

Test Suites: 1 passed, 1 total
Tests:       225 passed, 225 total
Snapshots:   0 total
Time:        1.51 s, estimated 2 s
Ran all test suites.
Waiting for the debugger to disconnect...
$ </code></pre>

<h2 id="advanced-topics">Advanced Topics</h2>

<h3 id="messagehandler">MessageHandler</h3>

<p>In some environments - specifically iOS apps and VSCode - you will want to get document state changes and other messages at a lower level than the MarkupDelegate. That level is the <em>MessageHandler</em>. The MarkupEditor’s default MessageHandler receives and processes <code>postMessage</code> as the document state changes, which it then passes-on to the MarkupDelegate (if the delegate exists and if the callback method exists in the delegate). Most developers will probably not even be aware that the MessageHandler exists. The MarkupDelegate callbacks will be sufficient for most developers.</p>

<p>The MessageHandler responds to the same kind of messages as the MarkupDelegate, but it sometimes does its own processing before informing the MarkupDelegate of the specific state change. For example, in the case of “ready”, the MessageHandler loads the initial HTML that was provided in the configuration or retrieves the contents of the filename, and then it loads that HTML into the document.</p>

<pre><code>postMessage(message) {
    let config = this.markupEditor.config
    let delegate = config.delegate

    switch (message) {
        // The editor posts `ready` when all scripts are loaded, so we can set the HTML. If HTML
        // is an empty document, then the config.placeholder will be shown.
        case 'ready':
            this.loadContents(config)
            delegate?.markupReady && delegate?.markupReady(this.markupEditor)
            return
        ... more cases
    }
...
}</code></pre>

<p>By the time your <code>delegate</code> receives <code>markupReady</code>, the document has been loaded and is ready to edit. This approach hides the complexity of fetching the file contents and dealing with failures. It reduces your input simply to providing a file name and avoids the MarkupDelegate having to decipher message types like the MessageHandler does.</p>

<p>For environments like iOS or VSCode, and perhaps others, you should set the MarkupEditor’s MessageHandler to one that is appropriate for the specific environment using <code>MU.setMessageHandler</code>. When you do that, <em>your MessageHandler is responsible for everything that the default MarkupEditor MessageHandler does</em>. For example, if you don’t load the <code>html</code> or <code>filename</code> contents when you receive the “ready” message, then nothing will show up in the editor.</p>

<h5>VSCode</h5>

<p>In VSCode, you would set the MessageHandler like this:</p>

<pre><code>vscode = acquireVsCodeApi();
MU.setMessageHandler(vscode);</code></pre>

<p>Now when the MarkupEditor executes its callbacks about document state changes (which it does in a VSCode WebviewPanel using <code>messageHandler?.postMessage(message)</code>), the <code>messageHandler</code> is <code>vscode</code>. When we created the VSCode WebviewPanel, we told it how to respond to messages:</p>

<pre><code>// Set up the message handler for messages coming from the webview
webviewPanel.webview.onDidReceiveMessage(this.handleMessage.bind(this));</code></pre>

<p>The messages in VSCode are JSON objects that include a <code>command</code> property which contains the message sent by the MarkupEditor callback.</p>

<p>You can review the source code for the <a href="https://github.com/stevengharris/markupeditor-vs">MarkupEditor VSCode extension</a> project for more details. Its MarkupCoordinator does the setup of the WebviewPanel, loading the MarkupEditor and dealing with the callbacks.</p>

<h5>UIKit and SwiftUI</h5>

<p>In an iOS project, you don’t have to set the MessageHandler explicitly, because the MarkupEditor sets it to <code>window.webkit?.messageHandlers?.markup</code> by default. This handy bit of legacy for iOS (and Mac Catalyst) developers exists because the MarkupEditor emerged first for Swift developers looking for WYSIWYG editing functionality.</p>

<p>In Swift, the MarkupEditor is embedded in a WKWebView. When <code>messageHandler?.postMessage(message)</code> is invoked, the message is handled by the WKScriptMessageHandler. The WKScriptMessageHandler for the Swift MarkupEditor is an instance of MarkupCoordinator, and messages are received in u<code>serContentController(_:didReceive:).</code></p>

<p>One other detail of the Swift MarkupEditor is that the toolbar is entirely implemented in SwiftUI. It uses the MarkupEditor with <code>ToolbarConfig.visibility.toolbar = false</code>. When the SwiftUI toolbar buttons are pressed, they directly invoke the MarkupEditor functionality using WKWebView’s <code>executeJavaScript</code> function.</p>

<p>You can review the source code and README for the <a href="https://github.com/stevengharris/MarkupEditor">Swift MarkupEditor</a> project for more details.</p>

<h3 id="markupeditor-project-structure">MarkupEditor Project Structure</h3>

<p>The <a href="https://github.com/stevengharris/markupeditor-base">MarkupEditor</a> is built using <a href="https://prosemirror.net">ProseMirror</a>. ProseMirror is a toolkit for building an editor. It’s well-<a href="https://prosemirror.net/docs/">documented</a>, well-architected, and has a lively and supportive <a href="https://discuss.prosemirror.net">forum</a>. You should <a href="https://marijnhaverbeke.nl/fund/">support it</a> if you can, particularly if you use the MarkupEditor to make a profit. If you want to modify the MarkupEditor itself, you will need to understand quite a bit about ProseMirror, a topic that is beyond the scope of this document. This section will cover a bit about the build and the structure of the MarkupEditor, as a way to help if you need to or want to modify it. You should be familiar with the <a href="https://github.com/stevengharris/markupeditor-base/blob/main/README.md">README</a> in the <a href="https://github.com/stevengharris/markupeditor-base">repository</a>.</p>

<p>As identified in the project’s <code>package.json</code> <code>files</code> section, there are two directories containing the critical files needed to use the MarkupEditor: <code>dist</code> and <code>styles</code>.</p>

<h4>Styles</h4>

<p>The <code>styles</code> directory contains css files needed by the editor. There are three files that need to be loaded in a specific order:</p>

<ol>
    <li>
        <p><strong><code>mirror.css</code></strong>: Styling needed to support basic ProseMirror editing, including the gap cursor and selection behavior.</p>
    </li>
    <li>
        <p><strong><code>markup.css</code></strong>: Styling needed to support basic MarkupEditor editing. For example, styling for the elements supported by the MarkupEditor and for resizing images.</p>
    </li>
    <li>
        <p><strong><code>toolbar.css</code></strong>: Styling needed for the toolbar. For example, how MenuItems and Dropdowns are styled.</p>
    </li>
</ol>

<p>To make loading the styles simpler, the directory contains a <code>markupeditor.css</code> that you can use, which includes the other css files in the proper order.</p>

<h4>Rolled-Up MarkupEditor JavaScript</h4>

<p>The <code>dist</code> directory contains the MarkupEditor JavaScript combined with its ProseMirror dependencies. The <code>dist</code> directory is produced using <a href="https://rollupjs.org">rollup</a>. It contains the same content bundled in various ways. The only format discussed and used here is the Universal Module Definition: <code>markupeditor.umd.js</code>. The corresponding CommonJS (<code>markupeditor.cjs.js</code>) and ECMAScript Module (<code>markupeditor.esm.js</code>) forms are also provided for convenience. The <code>npm build</code> command invokes <code>rollup -c</code> to produce the <code>dist</code> directory contents as specified in <code>rollup.config.mjs</code>.</p>

<h4>Key Files</h4>

<p>All the MarkupEditor-specific JavaScript source code is held within <code>src/js</code>. One of rollup's key features is <a href="https://rollupjs.org/faqs/#what-is-tree-shaking"><u>tree-shaking</u></a>, ensuring that only code used by the MarkupEditor is included. So, while it's possible that <code>src/js</code> contains code that is not reachable from the MarkupEditor, rollup ensures that only code reachable from <code>src/js/main.js</code> is included in the final <code>dist/markupmirror.umd.js</code>. The rollup-produced code in <code>dist/markupeditor.umd.js</code> is still readable and debuggable and includes comments.</p>

<p>The following file names and directories are relative to <code>src/js</code>. We have covered the various config files and the MessageHandler elsewhere, so they will not be discussed more here.</p>

<h5><code>main.js</code></h5>

<p>Everything starts at <code>main.js</code>. It creates the ProseMirror EditorView with an initial EditorState based on the Schema defined in <code>schema/index.js</code>. The EditorState includes a set of MarkupEditor-specific Plugins defined in <code>setup/index.js</code>. The view includes MarkupEditor-specific NodeViews defined in <code>markup.js</code>. It also includes special handling of some events to notify the Swift side of state changes. It's important to note that <code>main.js</code> specifies - in its exports - what the MarkupEditor public API is.</p>

<h5><code>markup.js</code></h5>

<p>This is the heart of the MarkupEditor functionality. As we have seen in earlier examples, the exported functions are invoked from with the prefix <code>MU</code>. For example, the JavaScript function to toggle the current selection to bold:</p>

<pre><code>export function toggleBold() {
    _toggleFormat('B');
};</code></pre>

<p>is invoked from within a script as <code>MU.toggleBold()</code>. Similarly, when invoked from, say, Electron, you would use <code>evaluateJavaScript</code> to access the same function.</p>

<p>Note that the exported functions in <code>markup.js</code> do not comprise the MarkupEditor API. The exports in <code>main.js</code> define the MarkupEditor API.</p>

<p>Included in <code>markup.js</code> are two ProseMirror NodeViews: <code>ImageView</code> and <code>DivView</code>. NodeViews provide special handling when rendering a ProseMirror Node. For example, the <code>ImageView</code> lets us handle image resizing in the MarkupEditor using a combination of CSS styling of resize handles and the logic in the <code>ResizableImage</code> class defined in <code>markup.js</code>.</p>

<h5><code>setup/index.js</code></h5>

<p>The <code>setup/index.js</code> file defines and returns the set of ProseMirror Plugins used by the MarkupEditor. These plugins are loaded from <code>main.js</code>. The plugins are commented reasonably well, but details of the code and what a ProseMirror Plugin is, are beyond the scope of this document.</p>

<h5><code>setup/keymap.js</code></h5>

<p>Sets up the keymapping/hotkeys for the MarkupEditor as specified in <code>setup/keymapconfig.js</code>. Beyond the ProseMirror example key mappings, the MarkupEditor includes list handling and table selection/navigation. The MarkupEditor also chains commands to <code>Enter</code> and <code>Delete</code> that invoke <code>stateChanged</code> (and potentially search) as needed.</p>

<h5><code>schema/index.js</code></h5>

<p>From the ProseMirror <a href="https://prosemirror.net/docs/ref/"><u>Reference manual</u></a>:</p>

<blockquote>
    <p>Every ProseMirror document conforms to a schema, which describes the set of nodes and marks that it is made out of, along with the relations between those, such as which node may occur as a child node of which other nodes.</p>
</blockquote>

<p>Basically, if it's not defined in the schema, then it cannot exist in a MarkupEditor document. For example, if you attempt to load HTML containing SPAN elements, they will be ignored. (This is not strictly true, since the MarkupEditor preprocesses HTML to extract SPAN contents that will be recognized by the MarkupEditor as defined in the Schema.) The end result is that MarkupEditor only produces "clean" HTML documents, not ones littered with SPANS and styles. You can paste from an HTML page in your browser, which often contains gnarly HTML because of whatever the web site used to produce it, but it will be brought into the MarkupEditor containing only the elements defined in the schema.</p>

<p>This file defines the Schema for the MarkupEditor. It's similar to the ProseMirror example, but includes such things as DIV and BUTTON to support usage of multiple <code>contenteditable</code> divs in the Swift MarkupEditor.</p>

<p></p>